From aa25a4df9f3465e747e0095b882ce691b5d5704d Mon Sep 17 00:00:00 2001
From: Heppokoyuki <yuhki.yasuda@gmail.com>
Date: Sat, 23 Jun 2018 15:47:50 +0900
Subject: [PATCH 3/3] =?UTF-8?q?=E3=82=AB=E3=82=A6=E3=83=B3=E3=82=BF?=
 =?UTF-8?q?=E3=83=BC!?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 HariboteOS.img | Bin 1474560 -> 1474560 bytes
 bootpack.c     |  17 +++++++-----
 haribote.h     |   5 ++--
 sheet.c        |  70 +++++++++++++++++++++++++++++++++++++++++--------
 4 files changed, 72 insertions(+), 20 deletions(-)

diff --git a/HariboteOS.img b/HariboteOS.img
index cd958eddb792a65148ac95f7aca0f8abe6002a3d..b065253d2994a5770c50466f3486aa42c84c9372 100644
GIT binary patch
delta 3993
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

delta 3040
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
H`9S#J_Xr8K

diff --git a/bootpack.c b/bootpack.c
index 82133fe..8061e56 100644
--- a/bootpack.c
+++ b/bootpack.c
@@ -13,7 +13,7 @@ void HariMain(void)
     struct SHEET *sht_back, *sht_mouse, *sht_win;
     unsigned char *buf_back, buf_mouse[256], *buf_win;
     char *mcursor, s[40], keybuf[32], mousebuf[128];
-    unsigned int memtotal;
+    unsigned int memtotal, count = 0;
     struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;
     int mx, my, i;
 
@@ -39,15 +39,13 @@ void HariMain(void)
     sht_mouse = sheet_alloc(shtctl);
     sht_win = sheet_alloc(shtctl);
     buf_back = (unsigned char *) memman_alloc_4k(memman, binfo->scrnx * binfo->scrny);
-    buf_win = (unsigned char *) memman_alloc_4k(memman, 160 * 68);
+    buf_win = (unsigned char *) memman_alloc_4k(memman, 160 * 52);
     sheet_setbuf(sht_back, buf_back, binfo->scrnx, binfo->scrny, -1);
     sheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99);
-    sheet_setbuf(sht_win, buf_win, 160, 68, -1);
+    sheet_setbuf(sht_win, buf_win, 160, 52, -1);
     init_screen8(buf_back, binfo->scrnx, binfo->scrny);
     init_mouse_cursor8(buf_mouse, 99);
-    make_window8(buf_win, 160, 68, "window");
-    putfonts8_asc(buf_win, 160, 24, 28, COL8_000000, "Welcome to");
-    putfonts8_asc(buf_win, 160, 24, 44, COL8_000000, "hogehogehog");
+    make_window8(buf_win, 160, 52, "counter");
     sheet_slide(sht_back, 0, 0);
     mx = (binfo->scrnx - 16) / 2;
     my = (binfo->scrny - 28 - 16) / 2;
@@ -64,9 +62,14 @@ void HariMain(void)
     sheet_refresh(sht_back, 0, 0, binfo->scrnx, 48);
 
     for(;;) {
+        count++;
+        sprintf(s, "%d", count);
+        boxfill8(buf_win, 160, COL8_C6C6C6, 40, 28, 119, 43);
+        putfonts8_asc(buf_win, 160, 40, 28, COL8_000000, s);
+        sheet_refresh(sht_win, 40, 28, 120, 44);
         _io_cli();
         if(fifo8_status(&keyfifo) + fifo8_status(&mousefifo) == 0) {
-            _io_stihlt();
+            _io_sti();
         }
         else {
             if(fifo8_status(&keyfifo) != 0) {
diff --git a/haribote.h b/haribote.h
index 80862cb..9a44d94 100644
--- a/haribote.h
+++ b/haribote.h
@@ -103,7 +103,7 @@ struct SHEET {
     struct SHTCTL *ctl;
 };
 struct SHTCTL {
-    unsigned char *vram;
+    unsigned char *vram, *map;
     int xsize, ysize, top;
     struct SHEET *sheets[MAX_SHEETS];
     struct SHEET sheets0[MAX_SHEETS];
@@ -179,7 +179,8 @@ void sheet_updown(struct SHEET *sht, int height);
 void sheet_refresh(struct SHEET *sht, int bx0, int by0, int bx1, int by1);
 void sheet_slide(struct SHEET *sht, int vx0, int vy0);
 void sheet_free(struct SHEET *sht);
-void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1);
+void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0, int h1);
+void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0);
 
 /*** sprintf.c ***/
 int decimalAsciiConvert(char *str, int dec);
diff --git a/sheet.c b/sheet.c
index e57d269..c0b1844 100644
--- a/sheet.c
+++ b/sheet.c
@@ -10,6 +10,12 @@ struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize
         goto err;
     }
 
+    ctl->map = (unsigned char *) memman_alloc_4k(memman, xsize * ysize);
+    if(ctl->map == 0) {
+        memman_free_4k(memman, (int) ctl, sizeof(struct SHTCTL));
+        goto err;
+    }
+
     ctl->vram = vram;
     ctl->xsize = xsize;
     ctl->ysize = ysize;
@@ -66,6 +72,8 @@ void sheet_updown(struct SHEET *sht, int height)
                 ctl->sheets[h]->height = h;
             }
             ctl->sheets[height] = sht;
+            sheet_refreshmap(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, height + 1);
+            sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, height + 1, old);
         } else {
             if(ctl->top > old) {
                 for(h = old; h < ctl->top; h++) {
@@ -74,8 +82,9 @@ void sheet_updown(struct SHEET *sht, int height)
                 }
             }
             ctl->top--;
+            sheet_refreshmap(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, 0);
+            sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, 0, old - 1);
         }
-        sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize);
     } else if(old < height) {
         if(old >= 0) {
             for(h = old; h < height; h++) {
@@ -91,7 +100,8 @@ void sheet_updown(struct SHEET *sht, int height)
             ctl->sheets[height] = sht;
             ctl->top++;
         }
-        sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize);
+        sheet_refreshmap(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, height);
+        sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, height, height);
     }
     return;
 }
@@ -99,19 +109,22 @@ void sheet_updown(struct SHEET *sht, int height)
 void sheet_refresh(struct SHEET *sht, int bx0, int by0, int bx1, int by1)
 {
     if(sht->height >= 0) {
-        sheet_refreshsub(sht->ctl, sht->vx0 + bx0, sht->vy0 + by0, sht->vx0 + bx1, sht->vy0 + by1);
+        sheet_refreshsub(sht->ctl, sht->vx0 + bx0, sht->vy0 + by0, sht->vx0 + bx1, sht->vy0 + by1, sht->height, sht->height);
     }
     return;
 }
 
 void sheet_slide(struct SHEET *sht, int vx0, int vy0)
 {
+    struct SHTCTL *ctl = sht->ctl;
     int old_vx0 = sht->vx0, old_vy0 = sht->vy0;
     sht->vx0 = vx0;
     sht->vy0 = vy0;
     if(sht->height >= 0) {
-        sheet_refreshsub(sht->ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht->bysize);
-        sheet_refreshsub(sht->ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize);
+        sheet_refreshmap(ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht->bysize, 0);
+        sheet_refreshmap(sht->ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize, sht->height);
+        sheet_refreshsub(sht->ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht->bysize, 0, sht->height - 1);
+        sheet_refreshsub(sht->ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize, sht->height, sht->height);
     }
     return;
 }
@@ -125,18 +138,19 @@ void sheet_free(struct SHEET *sht)
     return;
 }
 
-void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1)
+void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0, int h1)
 {
     int h, bx, by, vx, vy, bx0, by0, bx1, by1;
-    unsigned char *buf, c, *vram = ctl->vram;
+    unsigned char *buf, c, *vram = ctl->vram, *map = ctl->map, sid;
     struct SHEET *sht;
     if(vx0 < 0) vx0 = 0;
     if(vy0 < 0) vy0 = 0;
     if(vx1 > ctl->xsize) vx1 = ctl->xsize;
     if(vy1 > ctl->ysize) vy1 = ctl->ysize;
-    for(h = 0; h <= ctl->top; h++) {
+    for(h = h0; h <= h1; h++) {
         sht = ctl->sheets[h];
         buf = sht->buf;
+        sid = sht - ctl->sheets0;
         bx0 = vx0 - sht->vx0;
         by0 = vy0 - sht->vy0;
         bx1 = vx1 - sht->vx0;
@@ -149,9 +163,43 @@ void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1)
             vy = sht->vy0 + by;
             for(bx = bx0; bx < bx1; bx++) {
                 vx = sht->vx0 + bx;
-                c = buf[by * sht->bxsize + bx];
-                if(c != sht->col_inv) {
-                    vram[vy * ctl->xsize + vx] = c;
+                if(map[vy * ctl->xsize + vx] == sid) {
+                    vram[vy * ctl->xsize + vx] = buf[by * sht->bxsize + bx];
+                }
+            }
+        }
+    }
+    return;
+}
+
+void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)
+{
+    int h, bx, by, vx, vy, bx0, by0, bx1, by1;
+    unsigned char *buf, sid, *map = ctl->map;
+    struct SHEET *sht;
+
+    if(vx0 < 0) vx0 = 0;
+    if(vy0 < 0) vy0 = 0;
+    if(vx1 > ctl->xsize) vx1 = ctl->xsize;
+    if(vy1 > ctl->ysize) vy1 = ctl->ysize;
+    for(h = h0; h <= ctl->top; h++) {
+        sht = ctl->sheets[h];
+        sid = sht - ctl->sheets0;
+        buf = sht->buf;
+        bx0 = vx0 - sht->vx0;
+        by0 = vy0 - sht->vy0;
+        bx1 = vx1 - sht->vx0;
+        by1 = vy1 - sht->vy0;
+        if(bx0 < 0) bx0 = 0;
+        if(by0 < 0) by0 = 0;
+        if(bx1 > sht->bxsize) bx1 = sht->bxsize;
+        if(by1 > sht->bysize) by1 = sht->bysize;
+        for(by = by0; by < by1; by++) {
+            vy = sht->vy0 + by;
+            for(bx = bx0; bx < bx1; bx++) {
+                vx = sht->vx0 + bx;
+                if(buf[by * sht->bxsize + bx] != sht->col_inv) {
+                    map[vy * ctl->xsize + vx] = sid;
                 }
             }
         }
-- 
2.17.1

